var express = require("express");
var url = require("url");
var bodyParser = require('body-parser');
var randomstring = require("randomstring");
var cons = require('consolidate');
var nosql = require('nosql').load('database.nosql');
var querystring = require('querystring');
var __ = require('underscore');
__.string = require('underscore.string');

var app = express();

app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true })); // support form-encoded bodies (for the token endpoint)

app.engine('html', cons.underscore);
app.set('view engine', 'html');
app.set('views', 'files/authorizationServer');
app.set('json spaces', 4);

// authorization server information
var authServer = {
	authorizationEndpoint: 'http://localhost:9001/authorize',
	tokenEndpoint: 'http://localhost:9001/token'
};

// client information
var clients = [
	{
		"client_id": "oauth-client-1",
		"client_secret": "oauth-client-secret-1",
		"redirect_uris": ["http://localhost:9000/callback"]	// generated by the client
	}
];

var codes = {};

var requests = {};

var getClient = function(clientId) {
	return __.find(clients, function(client) { return client.client_id == clientId; });
};

app.get('/', function(req, res) {
	res.render('index', {clients: clients, authServer: authServer});
});

/**
 * Process the request, validate the client, and send the user to the approval page
 * Note that this is a front-channel endpoint, i.e. accessed by redirects through the browser.
 * this is to prevent the client getting any user info (as normally here you input your username/password)
 */
app.get("/authorize", function(req, res){
	
	var client = getClient(req.query.client_id)
	
	// For invalid client_id or invalid redirect_uris do not redirect using the redirect_uri and append error codes
	// This is because the redirect_uri is out of control of the auth server and may contain somehitng malicious, e.g. a phishing page or malware download
	if (!client) {
		console.log('Unknown client %s', req.query.client_id);
		res.render('error', {error: 'unknown client'})
		return
	} else if (!__.contains(client.redirect_uris, req.query.redirect_uri)) {
		console.log('Mismatched redirect URI, expected %s got %s', client.redirect_uris, req.query.redirect_uri);
		res.render('error', {error: 'Invalid redirect URI'})
		return
	} else {
		console.log("client found: ", client)

		// Ask the user for authorization and submit it back to the server
		var reqid = randomstring.generate(8)  // prevents cross-site request forgery for the authorisation (approve) page, since we will be grabbing data from that page
		requests[reqid] = req.query // store this query for later. In prod use the session or something like redis/postgres

		// Shows a page where clicking 'Approve' hits the auth-server's POST /approve endpoint with value 'Approve' or 'Deny'
		// we insert the reqid in the post's body via this trick <input type="hidden" name="reqid" value="<%- reqid %>">
		res.render('approve', {client: client, reqid: reqid})
		return
	}

});

/**
* Process the results of the approval page, authorize the client
*/
app.post('/approve', function(req, res) {

	// pull reqid and approval out of the post's body (which was submitted by the form)
	var reqid = req.body.reqid
	var query = requests[reqid]
	delete requests[reqid]

	if (!query) {
		res.render('error', {error: 'No matching authorization request'}) // if no matching query: possible cross-site forgery attack, therefore send to error page
		return
	}

	// Use front-channel communication again to take us back to the client whether approved or not
	if (req.body.approve) {
		// If approved we need to check what kind of response the client is asking for (e.g. authorization code grant type)
		if (query.response_type == 'code') {
			
			var code = randomstring.generate(8)
			
			codes[code] = { request: query };

			var urlParsed = buildUrl(query.redirect_uri, {
				code: code,
				state: query.state  // Stop attackers from hitting this clients /callback endpoint multiple times
			})
			res.redirect(urlParsed)
			return
		} else {
			var urlParsed = buildUrl(query.redirect_uri, {
				error: 'unsupported_response_type'
			})
			res.redirect(urlParsed)
			return
		}
	} else {
		// If denied we can safely tell the client what happened. 
		var urlParsed = buildUrl(query.redirect_uri, {error: 'access_denied'})
		res.redirect(urlParsed)
		return
	}
});

/**
 * Process the request, issue an access token
 */
app.post("/token", function(req, res){
	
	// Which client is making the request?
	var auth = req.headers['authorization'];
	if (auth) {
		var clientCredentials = decodeClientCredentials(auth)  // from Base64 encoding to plaintext
		var clientId = clientCredentials.id  // var makes clientId function-scoped, let would make it block-scoped
		var clientSecret = clientCredentials.secret
	}
	
	if (req.body.client_id) {
		if (clientId) {
			console.log('Client attempted to authenticate with multiple methods');
			req.statusCode(401).json({error: 'invalid_client'})
			return
		}
		var clientId = req.body.client_id;
		var clientSecret = req.body.client_secret;
	}

	// lookup the client provided
	var client = getClient(clientId)
	if (!client) {
		console.log('Unknown client %s', clientId);
		res.status(401).json({error: 'invalid_client'})
		return
	}

	if (client.client_secret != clientSecret) {
		console.log('Mismatched client secret, expected %s got %s', client.client_secret, clientSecret);
		res.status(401).json({error: 'invalid_client'})
		return
	}

	// now we know the client is valid, start processing requests for real
	if (req.body.grant_type == 'authorization_code') {
		var code = codes[req.body.code];

		// If the code exists, need to make sure it was issued to this client
		if (code) {
			delete codes[req.body.code]	// a stolen auth code presented by a bad client should be considered lost
			if (code.request.client_id == clientId) {
				// generate the token!
				// There is no defined structure for the token. Random string is fine, but so is JWT or SAML assertion
				// They can be signed, encrypted or both
				var access_token = randomstring.generate()  
				nosql.insert({access_token: access_token, client_id: clientId})
				console.log('Issuing access token %s', access_token);

				// send response back in body rather than header as endpoint is post, 
				// some client frameworks cannot access headers, and may want to return lots of data
				var token_response = { access_token: access_token, token_type: 'Bearer' }
				res.status(200).json(token_response)
				console.log('Issued tokens for code %s', req.body.code);
				return
			} else {
				console.log('Client mismatch, expected %s got %s', code.request.client_id, clientId);
				res.status(400).json({error: 'invalid_grant'})
				return
			}
		} else {
			console.log('Unknown code, %s', req.body.code);
			res.status(400).json({error: 'invalid_grant'})
			return
		}

	} else {
		console.log('Unknown grant type %s', req.body.grant_type);
		res.status(400).json({error: 'unsupported_grant_type'})
		return
	}


});

var buildUrl = function(base, options, hash) {
	var newUrl = url.parse(base, true);
	delete newUrl.search;
	if (!newUrl.query) {
		newUrl.query = {};
	}
	__.each(options, function(value, key, list) {
		newUrl.query[key] = value;
	});
	if (hash) {
		newUrl.hash = hash;
	}
	
	return url.format(newUrl);
};

var decodeClientCredentials = function(auth) {
	var clientCredentials = Buffer.from(auth.slice('basic '.length), 'base64').toString().split(':');
	var clientId = querystring.unescape(clientCredentials[0]);
	var clientSecret = querystring.unescape(clientCredentials[1]);	
	return { id: clientId, secret: clientSecret };
};

app.use('/', express.static('files/authorizationServer'));

// clear the database
nosql.clear();

var server = app.listen(9001, 'localhost', function () {
  var host = server.address().address;
  var port = server.address().port;

  console.log('OAuth Authorization Server is listening at http://%s:%s', host, port);
});
 
